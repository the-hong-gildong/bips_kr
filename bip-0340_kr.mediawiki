<pre>
  BIP: 340
  제목: secp256k1를 위한 슈노르 서명
  작성자: 피터 윌러(Pieter Wuille) <pieter.wuille@gmail.com>
          조나스 닉(Jonas Nick) <jonasd.nick@gmail.com>
          팀 러핑(Tim Ruffing) <crypto@timruffing.de>
  코멘트 요약: 아직 코멘트 없음.
  코멘트-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0340
  상태: 최종
  타입: 표준 트랙
  라이선스: BSD-2-Clause
  생성일: 2020-01-19
  이전 기록: 2018-07-06: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html [bitcoin-dev] Schnorr signatures BIP  
</pre>
* 원문: https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
* 싱크: https://github.com/bitcoin/bips/commit/5d10163efc36331eba5426dd854d91f0f68170f4

== 서론 ==

=== 초록 ===

이 문서는 ''secp256k1'' 타원 곡선 위에서 64 바이트 슈노르 서명을 위한 표준을 제안합니다.

=== 저작권 ===

이 BIP는 BSD-2-clause 라이센스에 따라 라이선스가 부여됩니다.

=== 동기 ===

전통적으로 비트코인은 트랜잭션 인증을 위해 [https://en.wikipedia.org/wiki/SHA-2 SHA256] 해시와 [https://www.secg.org/sec2-v2.pdf secp256k1 곡선] 위에서 정의된 [https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm ECDSA] 서명 을 사용합니다.
이것들은 [https://www.secg.org/sec1-v2.pdf 표준화] 되어있지만 동일한 커브에 대한 [http://publikationen.ub.uni-frankfurt.de/opus4/files/4280/schnorr.pdf 슈노르 서명]에 비해 여러 단점을 가지고 있습니다:

* '''증명 가능한 보안성''': 슈노르 서명은 안정성이 입증되었습니다. 자세히 설명하면,  슈노르 서명은 [https://www.di.ens.fr/~pointche/Documents/Papers/2000_joc.pdf 타원 곡선 이산 로그 문제(ECDLP)의 강도를 가정한 랜덤 오라클 모델]과  [http://www.neven.org/papers/schnorr.pdf 사용된 해시 함수의 사전 이미지 및 2차 사전 이미지 저항의 변형을 가정한 일반 그룹 모델]<ref>[https://www.di.ens.fr/~pointche/Documents/Papers/2000_joc.pdf 포인트슈발과 스턴의 최초의 보안성 증명]을 보다 명시적으로 재구성한 랜덤 오라클 모델의 자세한 보안성 증명은 [https://eprint.iacr.org/2016/191 킬츠, 마스니, 팬의 논문]에서 확인할 수 있습니다. 이러한 모든 보안성 증명은 ''(R,s)'' 대신 ''(e,s)''를 사용하는 슈노르 서명의 변형을 가정합니다(위의 설계를 보세요). ''R''의 유일한 인코딩을 사용하기 때문에 ''(R,s)''를 ''(e,s)''로 매핑하는 효율적인 계산 가능한 일대일 대응 함수가 있어 ''(e,s)'' 변형에 대한 성공적인 SUF-CMA 공격자를 ''(R,s)'' 변형에 대한 성공적인 SUF-CMA 공격자로 변환할 수 있습니다(그 반대의 경우도 마찬가지). 또한 증명은 키 접두화가 없는 슈노르 서명의 변형을 고려하지만(위의 설계를 보세요), 키 접두화가 있는 변형에 대해서도 증명이 정확하다는 것을 확인할 수 있습니다. 결과적으로 앞서 언급한 모든 보안성 증명은 이 문서에서 제안한 슈노르 서명의 변형에 적용됩니다.</ref>에서 ''선택된 메시지 공격에 강력하게 위변조 불가능(SUF-CMA)''합니다<ref>쉽게 말해, 비밀키를 모르면 임의의 메시지에 유효한 서명이 주어지더라도 더 이상 유효한 서명을 생각해낼 수 없다는 의미입니다.</ref>. 반면 [https://nbn-resolving.de/urn:nbn:de:hbz:294-60803 ECDSA의 입증 가능한 보안성에 대해 가장 잘 알려진 결과]는 더 큰 가정에 의존합니다.
* '''비가변성''': 슈노르 서명의 SUF-CMA 보안성은 비가변성을 의미합니다. 반면, ECDSA 서명은 태생적으로 가변성이 있습니다<ref>만약 ''(r,s)'' 가 주어진 메시지와 키에서 유효한 ECDSA 서명이라면 ''(r,n-s)'' 또한 같은 메시지와 키에서 유효합니다. 만약 두 변형 중 하나만 허용하도록 제한한다면 (비트코인이 네트워크의 정책 규칙으로 시행하는 것처럼), 일반적인 가정보다 더 강력한 가정 하에서 비가변성을 [https://nbn-resolving.de/urn:nbn:de:hbz:294-60803 증명]할 수 있습니다.</ref>; 비밀키에 액세스할 수 없는 제3자가 주어진 공개키와 메시지에 대한 기존의 유효한 서명을 동일한 키와 메시지에 유효한 다른 서명으로 변경할 수 있습니다. 이 이슈는 [[bip-0062.mediawiki|BIP62]]와 [[bip-0146.mediawiki|BIP146]]에서 논의 되었습니다.
* '''선형성''': 슈노르 서명은 여러 공동 작업 당사자가 각자의 공개키의 합산에 대해 유효한 서명을 생성할 수 있는 간단하고 효율적인 방법을 제공합니다. 이는 다중 서명과 다른 응용처럼 효율성과 개인정보 보호를 개선하는 다양한 상위 수준 응용을 위한 기본 요소입니다(아래 애플리케이션 참조).

이러한 모든 장점에도 불구하고 표준화되지 않았다는 점을 제외하면 사실상 단점은 없습니다. 이 문서는 이를 바꾸고자 합니다. 새로운 표준을 제안하면서 슈노르 서명에 국한되지 않고 여러 가지 개선이 이루어질 수 있습니다:

* '''서명 인코딩''': [https://en.wikipedia.org/wiki/X.690#DER_encoding DER]-인코딩을 사용하는 대신 (가변 사이즈이면서 최대 72 바이트), 간단한 64 바이트 고정 포맷을 사용할 수 있습니다.
* '''공개키 인코딩''': 오늘날 비트코인에서 일반적인 타원 곡선 포인트의 [https://www.secg.org/sec1-v2.pdf ''압축된''] 33 바이트 인코딩을 사용하는 대신, 이 프로토콜에서 공개키는 32 바이트로 인코딩 됩니다.
* '''일괄 검증(Batch verification)''': 표준화된 ECDSA 서명 공식의 일괄 검증은 추가 증인 데이터 없이 개별적인 검증보다 더 효율적으로 수행될 수 없습니다. 서명 체계를 바꾸는 것이 이것을 다룰 기회를 제공합니다.
* '''완전히 스펙화됨''': 합의 시스템에서 사용이 안전하기 위해서 검증 알고리즘은 바이트 수준에서 완전히 스펙화 되어야만 합니다. 이것은 일부 검증자에게만 유효하하고 모두에게 유효한 것은 아닌 서명을 누구도 생성 하지 못한다는 것을 보장합니다. 전통적으로 이것은 전자 서명 체계에 필수 조건은 아니었고 ECDSA 서명의 DER 파싱에 대한 정확한 스펙이 없는 것은 [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-July/009697.html 과거에] 비트코인의 문제를 야기했기 때문에 [[bip-0066.mediawiki|BIP66]] 에서 이것을 다룰 필요가 있었습니다. 이 문서에서는 이 속성을 충족하는 것을 목표로 설계할 것입니다. 검증자가 그들의 일괄 검증 대상(batches)을 고를 수 있기 때문에 태생적으로 비결정적인 일괄 검증에서, 이 속성은 검증의 결과가 의도적으로 일괄/비 일괄 검증을 다르게 하려는 공격자에게 조차 사소한 확률로 오직 개별 검증의 결과와 다르다는 것을 의미합니다.

비트코인이 ECDSA에 사용하는 것과 동일한 곡선과 해시 함수를 재사용함으로써 비밀키와 공개키를 선택하는 기존 메커니즘을 유지할 수 있으며, 타원 곡선과 해시 함수의 보안성에 대한 새로운 가정을 도입하지 않아도 됩니다.

== 설명 ==

먼저 디자인 선택을 통해 서명 체계의 대수적 공식을 구축합니다. 그런 다음 정확한 인코딩과 연산을 지정합니다.

=== 설계 ===

'''슈노르 서명 변형''' 메시지 ''m''과 공개키 ''P'' 를 위한 타원 곡선 슈노르 서명은 일반적으로 서명자에 의해 선택된 포인트 ''R'', 정수 ''e'', ''s'' 그리고 ''e = hash(R || m)'' 와 ''s⋅G = R + e⋅P''를 만족하는 베이스 포인트 ''G''를 포함합니다. 서명자가 ''e'' 또는 ''R'' 중 어떤 것을 드러내는지에 따라 두 가지 공식이 존재합니다:
# 서명은 ''e = hash(s⋅G - e⋅P || m)''을 만족하는 ''(e, s)'' 입니다. 이 변형은 서명 내부의 포인트 ''R'' 인코딩으로 인한 작은 복잡성을 피합니다("R 과 공개키 P 인코딩"과 "암시적 Y 좌표" 문단을 보세요). 게다가, ''R'' 대신 ''e''를 드러내는 것은 잠재적으로 더 짧은 서명이 가능합니다: ''R''은 약 32 바이트, 해시 ''e''는 32 바이트보다 작게 조절할 수 있습니다. [http://www.neven.org/papers/schnorr.pdf 오직 16 바이트의 짧은 해시는 128 비트 보안강도를 목표로 SUF-CMA 보안성을 제공하는데 충분합니다]. 하지만 짧은 해시충돌을 찾는것이 쉽다는 것은 이 최적화의 주요한 결함입니다. 이는 상호 불신하는 서명자 그룹이 하나의 공동 서명을 생성하기 위해 함께 작업하는 시나리오에서 보안 서명 프로토콜을 구현하는 것을 복잡하게 만듭니다(아래 애플리케이션 참조하세요). 하나의 정직한 서명자를 가정하는 SUF-CMA에 해당하지 않는 시나리오에서 악의적인 공동 서명자에게 유망한 공격 전략은 정직한 공동 서명자가 서명할 의도가 없는 메시지에 유효한 서명을 얻기 위해 해시 함수에서 충돌을 찾는 것입니다.
# 서명은 ''s⋅G = R + hash(R || m)⋅P''을 만족하는 ''(R, s)'' 입니다. 해시 내부에 타원 곡선 연산이 없기 때문에 일괄 검증을 지원합니다. 일괄 검증을 통해 속도를 크게 높일 수 있습니다.<ref>일괄 검증으로 인한 속도 향상은 암호학 라이브러리, [https://github.com/jonasnick/secp256k1/blob/schnorrsig-batch-verify/doc/speedup-batch.md libsecp256k1]를 통해 입증될 수 있습니다.</ref>

짧은 해시에서 오는 취약성을 피하고 싶기 때문에 ''e'' 변형은 특별한 장점을 제공하지 않습니다. 우리는 일괄 검증을 지원하는 ''R'' 옵션을 선택합니다.

'''키 접두화''' 위의 검증 규칙을 그대로 사용하는 것은 슈노르 서명을 "연관 키 공격(related-key attacks)"에 취약하게 만듭니다. 제 3자가 공개키 ''P''에 대한 서명 ''(R, s)'' 를 공개키 ''P + a⋅G'', 같은 메시지 ''m'' 그리고 비밀키에 대한 추가 조정 ''a''에 대해서 서명 ''(R, s + a⋅hash(R || m))'' 으로 변환할 수 있습니다. 이것은 키 생성에 [[bip-0032_kr.mediawiki#public-parent-key--public-child-key|BIP32의 비강화 유도]]와 탭루트 처럼 존재하는 키에 추가 조정하는 방법을 사용할 때 서명을 불안정하게 만듭니다.

이러한 공격으로부터 보호하기 위해 ''접두화된 키''<ref>(공개키의 짧은 해시에 커밋하거나 전혀 커밋하지 않는 것 대신) 공개키에 커밋하는 것의 한계는 공개키 복구 또는 짧은 공개키 해시에 대한 서명 확인 기능을 제거한다는 것입니다. 이러한 구조는 일반적으로 일괄 검증과 호환되지 않습니다.</ref> 슈노르 서명을 선택했습니다. 이것은 챌린지 해시 인풋 내의 메시지에 공개키가 접두화 된 것을 의미합니다. 이로 인해 수식이 ''s⋅G = R + hash(R || P || m)⋅P''으로 바뀝니다. 키 접두화가 추가 조정이 있는 연관 키 공격을 방어하는 것은 [https://eprint.iacr.org/2015/1135.pdf 증명 가능합니다]. 일반적으로 키 접두화는 다중 사용자 설정(multi-user settings)(예를 들어, MuSig, MuSig2, FROST 같은 멀티파티 사이닝 프로토콜 보안 증명의 필요 조건으로 보입니다. 아래 애플리케이션을 보세요)의 강건성을 증가시킵니다.

키 접두화가 현재 비트코인 트랜잭션 서명에 엄격히 필요한 것은 아니라는 것에 유의하세요. 왜냐하면, 서명된 트랜잭션은 이미 간접적으로 공개키에 커밋 되기 때문입니다(예를 들어, ''m''은 ''pk''에 대한 커미트먼트를 포함합니다). 하지만 간접 커미트먼트에 의존해서는 안됩니다. 왜냐하면 이것은 SIGHASH_NOINPUT([[bip-0118.mediawiki|BIP118]]) 같은 제안으로 바뀔 수 있고 서명 체계를 트랜잭션 서명 외의 다른 용도(예를 들어, [https://bitcoin.org/en/developer-reference#signmessage 평범한 메시지 서명])로 사용하기에 부적합하게 만들기 때문입니다.

'''R 과 공개키 P 인코딩''' 타원 곡선 포인트를 인코딩하는 몇 가지 가능한 방식이 있습니다:
# ''P'' 와 ''R''의 완전한 X, Y 좌표 인코딩. 64 바이트 공개키와 96 바이트 서명.
# 완전한 X 좌표 및 두 가지 가능성 중 하나를 판별하기 위한 1 비트 Y 좌표 인코딩. 33바이트 공개키와 65 바이트 서명.
# 오직 X 좌표만 인코딩. 32 바이트 공개키와 64 바이트 서명.

첫 번째 옵션은 검증이 조금 더 효율적(약 10%)이지만 압축성에 높은 우선순위를 두고 옵션 3을 선택합니다.

'''암시적 Y 좌표''' 효율적인 검증과 일괄 검증을 위해서 ''P'' 와 ''R'' 의 Y 좌표는 모호하면 안 됩니다(모든 유효한 X 좌표는 Y 좌표로 두 가지가 가능합니다). 대칭성을 제거하기 위해 몇 가지 옵션 중에서 선택할 수 있습니다:
# 작은 반에서 Y 좌표를 암시적으로 선택.
# 짝수인 Y 좌표를 선택<ref>''p''는 홀수이므로 부(-)의 모듈로 ''p''는 짝수를 홀수에 매핑하고 그 반대의 경우도 마찬가지입니다. 즉, 유효한 X 좌표의 경우 대응하는 Y 좌표 중 하나는 짝수이고 다른 하나는 홀수입니다.</ref>.
# 제곱 잉여(예를 들어, square root modulo ''p'')인 Y 좌표를 암시적으로 선택.

두 번째 옵션은 Y 좌표의 홀짝성을 나타내는 한 바이트와 완전한 X 좌표로 구성된 표준 33 바이트 압축된 공개키 포맷인 기존 키 생성 시스템과 가장 큰 호환성을 제공합니다. 불필요한 비호환성을 피하기 위해 우리는 ''P'' 를 위해 이 옵션을 선택합니다. 따라서 X 만 있는 공개키는 접두사 0x02 가 붙은 압축된 공개키와 같습니다. 일관성을 위해 ''R'' 에도 동일하게 적용합니다<ref>이 초안의 이전 버전에서는 일반적으로 서명 효율성과 검증 효율성을 맞바꿀 수 있다는 믿음에 따라 세 번째 옵션을 대신 사용했습니다. ECC 구현에서 일반적으로 최적화인 자코비안 좌표를 사용하는 경우, 먼저 (모듈러 인버전이 필요한) 아핀 좌표로 변환하지 않고 레제드레 기호를 계산하여 Y 좌표가 이차 잔차인지 확인할 수 있습니다. 모듈형 인버스와 레전드 기호는 실제로 [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-August/018081.html 성능]이 비슷하기 때문에 이 트레이드 오프는 그만한 가치가 없습니다.</ref>.

유효한 공개키 세트의 사이즈를 반으로 줄였음에도 불구하고 암시적 Y 좌표는 보안성을 감소시키지 않습니다. 쉽게 말해, X 만 있는 공개키의 이산 로그 문제를 푸는 알고리즘이 존재한다면 완전한 공개키의 이산 로그 문제에도 사용될 수 있습니다: X좌표에 적용하고 선택적으로 결과를 무시. 이것은 X만 있는 공개키를 해독하는 것이 완전한 공개키를 해독하는 것보다 기껏해야 작은 상수 시간만큼 빠를 수 있음을 보여줍니다<ref>이는 암시적 Y 좌표를 가진 슈노르 서명에 대한 공격을 명시적 Y 좌표를 가진 슈노르 서명에 대한 공격으로 축소하는 간단한 축소로 공식화할 수 있습니다. 이 감소는 공개 키를 다시 인코딩하고 챌린지 공개 키에 명시적 Y 좌표가 홀수일 때마다 무작위 오라클로 모델링된 해시 함수의 결과를 무효화하는 방식으로 작동합니다. 증명 스케치는 [https://medium.com/blockstream/reducing-bitcoin-transaction-sizes-with-x-only-pubkeys-f86476af05d7 여기]에서 확인할 수 있습니다.</ref>.

'''태그된 해시''' 암호학적 해시 함수는 여러 목적으로 아래 스펙과 비트코인에서 일반적으로 사용됩니다. 한 컨텍스트에서 사용된 해시가 다른 컨텍스트에서 재사용 되지 않는 다는 것을 확신하기 위해 해시 함수는 컨텍스트에 의존하는 태그로 조정될 수 있습니다. 이 방법으로 컨텍스트간 충돌은 실행 불가능한 것으로 가정할 수 있습니다. 분명 이러한 충동을 완전히 배제할 수 없고 고유한 이름으로 태그를 사용하는 체계에서만 가능합니다. 다른 체계의 경우 태그를 사용하면 적어도 태그를 사용하지 않을 때보다 충돌 가능성이 작습니다.

예를 들어, 태그된 해시 없이는 BIP340 서명이 오직 해시 함수의 전달 인자만 재정렬된 서명 체계에 대해서도 유효할 수 있습니다. 더 나쁜 경우에는, BIP340 논스 유도 함수가 복사되거나 독립적으로 생성된 경우, 해당 논스가 다른 체계에서 실수로 재사용되어 비밀키가 노출될 수 있습니다.

이 제안은 태그를 포함시키기 위해 해시된 데이터 앞에 ''SHA256(tag) || SHA256(tag)''를 접두사로 추가하는 것을 제안합니다. 왜냐하면 이것은 64바이트 길이의 컨텍스트별 상수이며 ''SHA256'' 블록 크기도 64바이트이기 때문에 최적화된 구현이 가능합니다(기존의 SHA256과 동일하지만 초기 상태가 수정된 것입니다). 태그 이름 자체의 SHA256을 사용하는 것은 최적화를 선택하지 않는 구현에 대해 상당히 간단하고 효율적입니다. 일반적으로 태그는 임의의 바이트 배열일 수 있지만, UTF-8 인코딩된 텍스트 설명을 사용하는 것이 권장됩니다.

'''최종 체계''' 최종 체계는 다음과 같습니다. 공개키 ''pk'' 는 Y좌표가 짝수인 곡선 위의 포인트 ''P''의 X 좌표 이고 서명 ''(r, s)''의 ''r''은 Y 좌표가 짝수인 포인트 ''R''의 X 좌표입니다. 서명은 ''s⋅G = R + tagged_hash(r || pk || m)⋅P''을 만족합니다.

=== 스펙 ===

다음의 컨벤션은 [https://www.secg.org/sec2-v2.pdf secp256k1]을 위해 정의된 상수와 함께 사용됩니다. 이 스펙을 다른 타원 곡선에 맞추는 것은 쉽지 않고 불안정한 체계를 초래할 수 있습니다<ref>다른 위험들 중, 논스 유도 함수의 범위가 곡선의 위수에 가깝지 않은 곡선과 이 스펙을 사용하는 것은 불안정합니다.</ref>.
* 소문자 변수는 정수 또는 바이트 배열을 나타냅니다.
** 상수 ''p'' 는 체(field)의 크기 ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''를 나타냅니다.
** 상수 ''n'' 은 곡선의 위수(order) ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''를 나타냅니다.
* 대문자 변수는 ''y<sup>2</sup> = x<sup>3</sup> + 7'' 를 만족하는 곡선 위의 포인트의 모듈러 ''p'' 를 나타냅니다.
** ''is_infinite(P)'' 는 ''P'' 가 무한대인지 아닌지를 반환합니다.
** ''x(P)'' 와 ''y(P)'' 는 ''0..p-1'' 범위의 정수이고 포인트 ''P'' 의 X 와 Y 좌표를 나타냅니다(무한대가 아니라고 가정합니다).
** 상수 ''G''는 베이스 포인트를 나타냅니다. ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' 이고 ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''입니다.
** 포인트의 덧셈은 보통의 [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law 타원 곡선 군 연산]을 따릅니다.
** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication 정수와 포인트의 곱 (⋅) 연산]은 군 연산의 반복입니다.
* 함수와 연산:
** ''||'' 는 바이트 배열의 결합을 나타냅니다.
** ''x''가 바이트 배열이고 ''i, j &ge; 0'' 인 함수 ''x[i:j]''는 ''x''의 ''i''번째 바이트(포함)에서 ''j''번째 바이트(불포함)까지 복사본인 ''(j - i)''바이트 배열을 반환 합니다.
** ''x''가 정수인 함수 ''bytes(x)''는 32 바이트 인코딩 된 ''x''를 반환합니다. MSB(Most significant byte)가 먼저 반환됩니다.
** 포인트 ''P'' 인 함수 ''bytes(P)''는 ''bytes(x(P))''를 반환합니다.
** ''x''가 바이트 배열일 함수''int(x)''는 MSB(Most significant byte)를 먼저 인코딩 하면 ''x''인 부호 없는 정수 256-bit를 반환합니다. 
** ''not is_infinite(P)''를 만족하는 포인트 ''P'' 에 대해 함수 ''has_even_y(P)''는 ''y(P) mod 2 = 0''를 반환합니다.
** ''x''가 부호 없는 256 비트 정수인 함수 ''lift_x(x)''는 ''x(P) = x''인 포인트 ''P''<ref>''0..p-1'' 범위의 후보 X좌표 ''x''가 주어지면 Y 좌표는 정확히 두 개 존재하거나 존재하지 않습니다. 만약 유효한 Y 좌표가 존재하지 않는다면 ''x'' 또한 유효한 X 좌표가 아닙니다. 즉, ''x(P) = x''인 ''P''가 존재하지 않습니다. 주어진 후보 ''x''에 대해 유효한 Y 좌표는 ''c = x<sup>3</sup> + 7 mod p'' 의 제곱근이며, 존재하는 경우 ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' ([https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus 이차 잔차]를 보세요)으로 계산할 수 있으며, 제곱한 후 ''c''와 비교하여 확인할 수 있습니다.</ref> 와 ''has_even_y(P)''를 반환하거나 만약 ''x'' 가 ''p-1'' 보다 크거나 그런 포인트가 없으면 실패합니다. 함수 ''lift_x(x)'' 는 다음 수도코드와 동일합니다:
*** 만약 ''x &ge; p''이면 실패.
*** ''c = x<sup>3</sup> + 7 mod p''.
*** ''y = c<sup>(p+1)/4</sup> mod p''.
*** 만약 ''c &ne; y<sup>2</sup> mod p''이면 실패.
*** ''x(P) = x''이고, 만약''y mod 2 = 0''이면 ''y(P) = y'', 그렇지 않다면 ''y(P) = p-y''인 유일한 포인트 ''P'' 를 반환합니다.

** ''x''가 바이트 배열인 함수 ''hash<sub>name</sub>(x)'' 는 ''tag'' 가 ''name''의 UTF-8 인코딩인 32 바이트 해시 ''SHA256(SHA256(tag) || SHA256(tag) || x)''를 반환합니다.

==== 공개키 생성 ====

입력:
* 비밀키 ''sk'': 무작위로 균일하게 새로 생성되는 32 바이트 배열

알고리즘 ''PubKey(sk)'' 는 다음과같이 정의됩니다:
* ''d' = int(sk)''.
* ''d' = 0'' 또는 ''d' &ge; n''이면 실패.
* ''bytes(d'⋅G)''를 반환.

우리는 기존 시스템(일반적으로 타원 곡선의 포인트에 사용되는 공개키, 또는 그것들의 33바이트 또는 65 바이트 인코딩)과 아주 다른 공개키 포맷(32 바이트)을 사용하는 것에 유의하세요. 부가적인 효과로 ''PubKey(sk) = PubKey(bytes(n - int(sk)))'' 를 만족합니다. 따라서 모든 공개키는 대응하는 두 개의 비밀키를 가집니다.

==== 공개키 변환 ====

임의로 키를 생성하는 대신 기존의 ECDSA 키 생성 알고리즘을 호환성 있게 사용할 수 있습니다. 이러한 알고리즘으로 생성된 비밀키는 ''sk''로 직접 사용할 수 있습니다. 이러한 알고리즘(33 바이트 압축 인코딩을 사용한 것으로 가정)으로 생성된 공개키는 첫 번째 바이트를 버려서 변환할 수 있습니다. 특히, [[bip-0032_kr.mediawiki|BIP32(kr)]] 와 그 위에 구축된 체계는 여전히 사용 가능합니다.

==== 기본 서명 ====

입력:
* 비밀키 ''sk'': 32 바이트 배열
* 메시지 ''m'': 바이트 배열
* 보조 랜덤 데이터 ''a'': 32 바이트 배열

알고리즘 ''Sign(sk, m)'' 은 다음과 같이 정의됩니다:
* ''d' = int(sk)''
* 만약 ''d' = 0'' 또는 ''d' &ge; n'' 이면 실패
* ''P = d'⋅G''
* 만약 ''has_even_y(P)'' 이면 ''d = d' '', 그렇지 않으면 ''d = n - d' ''.
* ''t'' 는 ''bytes(d)''와 ''hash<sub>BIP0340/aux</sub>(a) 의 비트단위 xor 연산 결과 ''<ref>보조 무작위 데이터는 무작위성이 개인키 자체와 연관될(correlated) 수 있는 상황에 대한 예방책으로 (고유 태그와 함께)해시됩니다. 실제 비밀 키에 노출되는 연산 횟수를 줄이기 위해 (해시 안에서 개인 키와 결합하지 않고) 개인 키와 함께 XOR 됩니다.</ref>.
* ''rand = hash<sub>BIP0340/nonce</sub>(t || bytes(P) || m)''<ref>[https://moderncrypto.org/mail-archive/curves/2020/001012.html 논스 해시에 공개키를 입력]으로 포함하는 것은 알고리즘의 강건성을 보장하는데 도움을 줍니다. 공개키 ''P''의 계산이 잘못되거나 악의적으로 수행되는 경우, 예를 들어 성능상의 이유로 호출자에게 맡겨진 경우에도 비밀키의 유출을 방지합니다.</ref>.
* ''k' = int(rand) mod n''<ref>균일한 256 비트 난수 정수의 모듈러 곡선의 위수 연산을 취하면 일반적으로 허용할 수 없을 정도로 편향된 결과가 생성됩니다. 그러나 secp256k1 곡선의 경우 위수가 ''2<sup>256</sup>''에 충분히 가깝기 때문에 이 편향은 관찰되지 않습니다(''1 - n / 2<sup>256</sup>'' 은 약 ''1.27 * 2<sup>-128</sup>'' 입니다).</ref>.
* 만약 ''k' = 0'' 이면 실패.
* ''R = k'⋅G''.
* 만약 ''has_even_y(R)'' 이면 ''k = k' '', 그렇지 않으면 ''k = n - k' ''.
* ''e = int(hash<sub>BIP0340/challenge</sub>(bytes(R) || bytes(P) || m)) mod n''.
* ''sig = bytes(R) || bytes((k + ed) mod n)''.
* 만약 ''Verify(bytes(P), m, sig)'' (아래를 보세요) 가 실패를 반환하면 중단(abort)<ref>서명자를 떠나기 전에 서명을 검증하면 무작위 또는 공격자가 유발한 계산 오류를 방지할 수 있습니다. 이렇게 하면 비밀 키에 대한 정보가 유출될 수 있는 유효하지 않은 서명을 발행되는 것을 방지할 수 있습니다. 이 방법은 권장되지만 계산 비용이 너무 많이 드는 경우 생략할 수 있습니다.</ref>.
* 서명 ''sig''를 반환.

보조 랜덤 데이터는 서명 시점에 새롭게 무작위로 생성되어야 하고 이것을 ''합성 논스(synthetic nonce)''라고 부릅니다. 32바이트 무작위성을 사용하는 것이 최적입니다. 무작위성을 얻는 비용이 크다면 16개의 무작위 바이트에 16개의 널 바이트를 추가하여 32바이트 배열을 얻을 수 있습니다. 서명 시점에 무작위성을 전혀 사용할 수 없는 경우, 실제로 반복되지 않을 만큼 충분히 넓고(예: 64비트 이상) 32바이트 배열에 널 바이트를 추가한 간단한 카운터를 사용하거나 32개의 널 바이트가 있는 상수 배열을 사용할 수도 있습니다. 반복되지 않는 값을 사용하면 [https://moderncrypto.org/mail-archive/curves/2017/000925.html 오류 주입 공격(fault injection attacks)]에 대한 보호 기능이 향상됩니다. 예측할 수 없는 무작위성을 사용하면 다른 부채널 공격에 대한 보호 기능이 추가로 강화되므로 '''가능한 경우 항상 권장됩니다'''. 이는 생성된 논스가 결정론적이지 않다는 것을 의미하지만, 무작위성은 보안을 위한 보조적인 요소일 뿐입니다. 일반적인 보안 특성(사이드 채널 공격 제외)은 서명 시간의 RNG 품질에 의존하지 않습니다.

==== 대체 서명(Alternative Signing) ====

다양한 대체 서명 알고리즘을 사용하여 똑같이 유효한 서명을 생성할 수 있다는 점에 유의하세요. 32바이트 ''랜덤'' 값은 다른 방식으로 생성되어 다르지만 여전히 유효한 서명을 생성할 수 있습니다(즉, 이는 ''유일한'' 서명 체계가 아닙니다). '''랜덤 값을 생성하는데 어떤 방법이 사용되든 그 값은 항상 공격자가 부분적으로 예측할 수 없는 새로운 균일하게 무작위인 32바이트 문자열이어야 합니다.''' 무작위성이 없는 논스라면 동일한 입력이 다른 컨텍스트에서 제공되어서는 안 됩니다. 이는 하나의 개인 키를 여러 서명 체계에서 재사용하지 않음으로써 가장 안정적으로 달성할 수 있습니다. 예를 들어, RFC6979에 따라 ''랜덤'' 값을 계산하고 RFC6979를 사용하는 결정론적 ECDSA에서 동일한 비밀 키를 사용하는 경우, 논스 재사용을 통해 서명이 비밀 키를 유출할 수 있습니다.

'''논스 유출 방지''' 2차 장치를 사용하여 논스 생성 알고리즘을 강화할 수 있습니다. 이 경우 2차 장치는 실제 서명자가 증명할 수 있는 무작위성을 논스에 추가합니다. 이렇게 하면 손상된 서명자의 장치가 논스 선택을 통해 의도적으로 비밀 키를 유출시키는 특정 공격을 방지할 수 있습니다.

'''다중 서명''' 이 서명 체계는 하나의 공개키가 여러 비밀키의 소유자들이 서명에 참여하길 요구하는 [https://eprint.iacr.org/2020/1261.pdf MuSig2]와 같은 다양한 유형의 다중 서명 및 임계값 체계와 호환됩니다(아래 애플리케이션을 보세요). '''일반적으로 다중 서명 서명 체계는 위의 기본 서명 알고리즘(또는 다른 결정론적 방법)의 ''랜덤'' 값 생성을 사용하면 안전하지 않다는 점에 유의해야 합니다.'''

'''미리 계산된 공개키 데이터''' 많은 경우 비밀키에 대응하는 공개키의 압축된 33바이트 인코딩을 이미 알고 있을 수 있으므로 ''has_even_y(P)'' 와 ''bytes(P)''를 쉽게 평가할 수 있습니다.  따라서 서명자가 직접 공개키를 제공하는 것이 비밀키에서 공개키를 다시 계산하는 것보다 더 효율적일 수 있습니다. 그러나 이 최적화를 사용하고 서명 알고리즘의 효율성을 높이기 위해 서명 알고리즘 마지막에 서명 확인을 추가로 생략하는 경우, 서명자는 공개 키가 올바르게 계산되고 신뢰할 수 없는 출처에서 가져온 것이 아닌지 확인해야 합니다.

==== 검증 ====

입력:
* 공개키 ''pk'': 32 바이트 배열
* 메시지 ''m'': 바이트 배열
* 서명 ''sig'': 64 바이트 배열

알고리즘 ''Verify(pk, m, sig)'' 는 다음과 같이 정의됩니다:
* ''P = lift_x(int(pk))''; 만약 실패하면 실패.
* ''r = int(sig[0:32])''; 만약 ''r &ge; p'' 이면 실패.
* ''s = int(sig[32:64])''; 만약 ''s &ge; n'' 이면 실패.
* ''e = int(hash<sub>BIP0340/challenge</sub>(bytes(r) || bytes(P) || m)) mod n''.
* ''R = s⋅G - e⋅P''.
* 만약 ''is_infinite(R)'' 이면 실패.
* 만약 ''not has_even_y(R)'' 이면 실패.
* 만약 ''x(R) &ne; r'' 이면 실패.
* 이 지점에 도달하기 전에 실패가 발생하지 않으면 성공을 반환.

모든 유효한 비밀키 ''sk'' 와 메시지 ''m'' 에 대해서 ''Verify(PubKey(sk),m,Sign(sk,m))'' 는 성공합니다.

검증의 올바름은 ''lift_x''가 항상 짝수 Y 좌표를 반환한다는 것에 의존한다는 점을 유의하세요. 홀수 Y 좌표가 사용되면 포이트 ''P''가 바로 입력으로 사용되는 검증 알고리즘은 항상 실패합니다. 추가 처리 전에 홀수 Y 좌표를 가진 점을 무효화하여 이를 수정할 수는 있지만, 이렇게 하면 모든 (메시지, 서명) 쌍이 두 개의 공개 키에 유효한 체계가 됩니다(ECDSA에도 존재하는 일종의 가변성이지만 우리는 유지하고 싶지 않습니다). 이런 문제들을 피하기 위해 단지 공개키의 X 좌표만을 다룹니다.

==== 일괄 검증(Batch verification) ====

입력:
* 서명의 수 ''u''
* 공개키 ''pk<sub>1..u</sub>'': ''u''개의 32바이트 배열
* 메시지 ''m<sub>1..u</sub>'': ''u''개의 바이트 배열
* 서명 ''sig<sub>1..u</sub>'': ''u''개의 64바이트 배열

알고리즘 ''BatchVerify(pk<sub>1..u</sub>, m<sub>1..u</sub>, sig<sub>1..u</sub>)'' 은 다음과 같이 정의됩니다:
* ''1...n-1'' 범위의 임의의 정수 ''a<sub>2...u</sub>'' ''u-1'' 개를 생성합니다. 이 랜덤 값들은 알고리즘의 모든 인풋의 암호학적 해시 값을 시드로 쓰는 [https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator CSPRNG]을 이용하여 결정적으로 생성됩니다(예를 들어, ''seed = seed_hash(pk<sub>1</sub>..pk<sub>u</sub> || m<sub>1</sub>..m<sub>u</sub> || sig<sub>1</sub>..sig<sub>u</sub> )''). ''seed_hash''에 SHA256을 사용하고 [https://tools.ietf.org/html/rfc8439 ChaCha20]을 CSPRNG 의 키 ''시드''로 사용해서 256 비트 정수를 생성(''1...n-1'' 범위 밖의 정수는 건너 뜀) 하는 것은 안전한 선택입니다.
* ''i = 1 .. u''에 대해서:
** ''P<sub>i</sub> = lift_x(int(pk<sub>i</sub>))''; 만약 실패하면 실패.
** ''r<sub>i</sub> = int(sig<sub>i</sub>[0:32])''; 만약 ''r<sub>i</sub> &ge; p'' 이면 실패.
** ''s<sub>i</sub> = int(sig<sub>i</sub>[32:64])''; 만약 ''s<sub>i</sub> &ge; n'' 이면 실패.
** ''e<sub>i</sub> = int(hash<sub>BIP0340/challenge</sub>(bytes(r<sub>i</sub>) || bytes(P<sub>i</sub>) || m<sub>i</sub>)) mod n''.
** ''R<sub>i</sub> = lift_x(r<sub>i</sub>)''; 만약 ''lift_x(r<sub>i</sub>)'' 가 실패하면 실패.
* 만약 ''(s<sub>1</sub> + a<sub>2</sub>s<sub>2</sub> + ... + a<sub>u</sub>s<sub>u</sub>)⋅G &ne; R<sub>1</sub> + a<sub>2</sub>⋅R<sub>2</sub> + ... + a<sub>u</sub>⋅R<sub>u</sub> + e<sub>1</sub>⋅P<sub>1</sub> + (a<sub>2</sub>e<sub>2</sub>)⋅P<sub>2</sub> + ... + (a<sub>u</sub>e<sub>u</sub>)⋅P<sub>u</sub>'' 이면 실패.
* 이 지점에 도달하기 전에 실패가 발생하지 않으면 성공을 반환.

모든 개별 서명이 유효하면(즉, ''Verify''가 모든 서명에 대해 성공을 반환하는 경우), ''BatchVerify''는 항상 성공을 반환합니다. 하나 이상의 서명이 유효하지 않은 경우, ''BatchVerify''는 기껏해야 무시할 수 있는 확률로 성공을 반환합니다.

=== 사용시 고려 사항 ===

==== 임의 크기의 메시지 ====

이 BIP에 지정된 서명 체계는 임의의 크기의 바이트 문자열을 입력 메시지로 허용합니다.<ref>이론적으로 SHA256은 2^61-1바이트 크기까지만 바이트 문자열을 허용하기 때문에 메시지 크기가 제한되어 있습니다.</ref> 환경 또는 애플리케이션 컨텍스트에서 너무 큰 메시지(예를 들어, 미리 정의된 버퍼를 초과하거나 리소스 소모를 유발하는 메시지)가 거부되도록 구현하는 것은 허용됩니다.

이 BIP의 이전 버전에서는 메시지의 크기가 정확히 32바이트여야 했습니다. 이러한 제한은 일반적으로 서명 또는 검증에 전달할 수 있는 32바이트 다이제스트를 생성하기 위해 SHA256(또는 다른 충돌 방지 암호화 해시 함수)을 통해 실제 입력 메시지의 사전 해싱을 수행해야 하는 호출자에게 부담을 주게 됩니다. ([[bip-0341.mediawiki|BIP341]]에서와 같이)

실제 메시지가 32바이트보다 짧은 경우<ref>사전 해싱을 생략하는 또 다른 이유는 사전 해싱에 사용되는 해시 함수에 대한 특정 유형의 암호화 분석 발전으로부터 보호하기 위해서입니다. 사전 해싱을 사용하면 사전 해싱 함수에서 충돌을 찾을 수 있는 공격자는 선택 메시지 공격에서 서명을 위조할 수 있습니다. 사전 해싱을 사용하지 않는 경우, 서명 체계 내부에서 사용되는 SHA256에서 충돌을 찾을 수 있는 공격자는 서명을 위조할 수 없을 것입니다. 그러나 이러한 장점은 트랜잭션 해시 등 다른 곳에서 이미 SHA256의 충돌 저항에 의존하는 비트코인의 상황에서는 대부분 무의미합니다.</ref> 등 사전 해싱이 항상 바람직하지 않을 수 있으므로 32바이트 메시지에 대한 제한이 해제되었습니다. 대용량 메시지를 처리하는 애플리케이션에서는 성능상의 이유로 사전 해싱을 권장합니다. 대용량 메시지를 미리 해시하지 않으면 서명 체계의 알고리즘이 내부적으로 더 많은 해싱을 수행합니다. 특히 서명 알고리즘은 메시지에 대해 두 번의 순차적인 해시 전달이 필요하므로 서명하는 동안 전체 메시지를 반드시 메모리에 보관해야 하며, 메시지가 크면 런타임 페널티가 발생하게 됩니다.<ref>서명 알고리즘 내부의 SHA256 속도가 호출 애플리케이션에서 수행하는 사전 해싱의 속도와 일치한다고 가정할 때 일반적으로 56바이트 이상의 메시지는 사전 해싱을 통해 성능상의 이점을 누릴 수 있습니다.</ref>

==== 도메인 분리 ====

하나의 키 쌍을 하나의 용도로만 사용하는 것이 좋은 암호화 관행입니다. 그럼에도 불구하고 여러 상황에서 동일한 키 쌍을 사용하는 것이 바람직한 경우가 있을 수 있습니다. 즉, 동일한 애플리케이션 내에서 서로 다른 유형의 메시지에 서명하거나 완전히 다른 애플리케이션의 메시지에 서명할 수 있습니다. (예를 들어, 비밀 키는 비트코인 트랜잭션 서명뿐만 아니라 일반 문자 메시지에 서명하는 데도 사용될 수 있습니다).

따라서 애플리케이션은 한 컨텍스트를 위해 서명된 애플리케이션 메시지가 다른 컨텍스트에서 유효하다고 간주되지 않도록 해야 합니다(예를 들어, 서명된 일반 텍스트 메시지를 서명된 비트코인 거래로 잘못 해석하면 의도하지 않은 자금 손실이 발생할 수 있으므로). 이를 "도메인 분리"라고 하며, 일반적으로 메시지 공간을 분할하여 구현합니다. 키 쌍을 단일 컨텍스트 내에서만 사용하려는 경우에도 도메인 분리는 나중에 더 많은 컨텍스트를 쉽게 추가할 수 있기 때문에 좋은 아이디어입니다.

최선의 방법으로 애플리케이션 메시지를 서명 체계에 전달하기 전에 다음 방법 중 하나를 사용하여 애플리케이션 메시지를 사전 처리하는 것이 권장됩니다:
* ''hash<sub>name</sub>''를 사용하여 애플리케이션 메시지를 미리 해시하고, 여기서 ''name''은 컨텍스트를 고유하게 식별합니다. (예를 들어, "foo-app/signed-bar"),
* 또는 실제 메시지 앞에 컨텍스트를 고유하게 식별하는 33바이트 문자열을 접두사로 붙입니다. (예를 들어, 33 바이트가 되도록 널 바이트가 패딩된 "foo-app/signed-bar"의 UTF-8 인코딩).

두 가지 전처리 방법은 서로 다른 메시지 크기(32바이트와 최소 33바이트)를 생성하므로 서로 충돌할 위험이 없습니다.

== 애플리케이션 ==

단순한 서명 외에도 몇 가지 흥미로운 애플리케이션이 있습니다. 최근 학술 논문에서는 ECDSA로도 가능하다고 주장하지만, 슈노르 서명 검증에 대한 합의 지원은 구조를 상당히 단순화할 수 있습니다.

=== 다중 서명 및 임계값 서명 ===

[https://eprint.iacr.org/2020/1261.pdf MuSig2] ([[bip-0327.mediawiki|BIP327]])와 같은 대화형 체계를 통해 참여자들은 그들의 공개키들을 하나의 공개키로 통합하여 공동으로 서명할 수 있습니다. 이를 통해 검증자 입장에서는 일반 서명과 다를 바 없는 ''n''-of-''n''의 다중 서명이 가능하며, ''CHECKMULTISIG'' 또는 다른 수단과 비교하여 향상된 프라이버시 및 효율성을 제공합니다.

게다가 슈노르 서명은 [https://en.wikipedia.org/wiki/Distributed_key_generation 분산키 생성]과 호환되므로 대화형 임계값 서명 체계를 가능하게 합니다. 예를 들어, [http://cacr.uwaterloo.ca/techreports/2001/corr2001-13.ps 스틴슨과 스트로블 (2001)], [https://link.springer.com/content/pdf/10.1007/s00145-006-0347-3.pdf 젠나로, 야레키, 크로치크 그리고 래빈 (2007)], [https://eprint.iacr.org/2020/852.pdf 콤로 그리고 골드버그 (2020)] 또는  or [https://eprint.iacr.org/2023/899.pdf 추, 겔하트, 루핑, 그리고 슈뢰더 (2023)]의 체계가 있습니다. 또 [https://eprint.iacr.org/2023/899.pdf FROST3] 같은 변형을 포함하는 [https://eprint.iacr.org/2020/852.pdf FROST] 체계를 가능하게 합니다.

이러한 프로토콜을 사용하면 ''k''-of-''n''의 임계값 서명을 구현할 수 있으며, 이는 ''n'' 서명자 집합에서 ''k'' 크기의 모든 하위 집합이 서명할 수 있지만 ''k''보다 작은 크기의 하위 집합은 유효한 슈노르 서명을 생성할 수 없음을 보장합니다.

=== 어댑터 서명 ===

[https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2018-05-18-l2/slides.pdf 어댑터 서명]은 서명자가 자신의 공개 논스 ''R''을 알려진 포인트 ''T = t⋅G''로 상쇄하여 생성할 수 있지만, 서명의 ''s'' 값은 상쇄하지 않습니다. 동일한 논스를 사용하는 동일한 메시지에 대한 올바른 서명(또는 다중 서명에 대한 개별 서명자의 기여를 부분 서명이라고 함)은 ''t''로 상쇄된 어댑터 서명과 같으므로, ''t''를 배우는 것은 올바른 서명을 배우는 것과 동일합니다. 이는 비트코인 스크립트 지원 대신 서명 자체를 사용해 분리된 트랜잭션의 원자성을 보장하는 아토믹 스왑 또는 [https://eprint.iacr.org/2018/472 일반 결제 채널]을 활성화하는 데 사용할 수 있습니다. 결과 트랜잭션은 검증자에게 잠금 시간 환불 로직이 포함된 것을 제외하면 일반 단일 서명자 트랜잭션과 다르지 않은 것처럼 보입니다.

어댑터 서명은 스크립트 의미론을 일정한 크기의 서명으로 인코딩하는 효율성 및 프라이버시 이점 외에도 기존 해시 기반 결제 채널에 비해 추가적인 이점이 있습니다. 특히, 비밀 값 ''t''는 홉 간에 다시 블라인드되어 긴 트랜잭션 체인을 원자적으로 만들 수 있으며, 참여자조차 어떤 트랜잭션이 체인의 일부인지 식별할 수 없습니다. 또한 비밀 값은 키 생성 시점이 아닌 서명 시점에 선택되기 때문에, 기존 출력은 블록체인에 의존하지 않고도 여러 번 다른 애플리케이션에 맞게 용도를 변경할 수 있습니다.

=== 블라인드 서명 ===

블라인드 서명 프로토콜은 서명자가 서명된 메시지나 서명에 대한 정보를 알지 못한 채 상대방의 요청에 따라 메시지에 서명할 수 있는 대화형 프로토콜입니다. 슈노르 서명은 매우 [http://publikationen.ub.uni-frankfurt.de/files/4292/schnorr.blind_sigs_attack.2001.pdf 간단한 블라인드 서명 체계]를 허용하지만 [https://www.iacr.org/archive/crypto2002/24420288/24420288.pdf 바그너의 공격]에 취약하기 때문에 안전하지 않습니다. 알려진 완화 방법은 서명자가 특정 확률로 서명 세션을 중단하거나(이 방법은 [https://eprint.iacr.org/2019/877 비표준 암호화 가정 하에서 결과 체계가 안전한 것으로 입증될 수 있습니다] ) [https://eprint.iacr.org/2022/1676.pdf 영지식 증명을 사용]하는 것입니다.

예를 들어 블라인드 슈노르 서명은 퍼블릭 블록체인 거래 그래프에서 거래자를 연결하지 않고 신뢰할 수 없는 에스크로 에이전트가 중개하는 코인을 전송할 수 있는 구조인 [https://github.com/ElementsProject/scriptless-scripts/blob/master/md/partially-blind-swap.md 부분 블라인드 아토믹 스왑]에 사용될 수 있습니다.

== 테스트 벡터와 참조 코드 ==

개발 및 테스트 목적으로 [[bip-0340/test-vectors.csv|CSV 형식의 테스트 벡터 모음]]과 나이브하고 매우 비효율적이며 시간이 일정하지 않은 [[bip-0340/reference.py|서명 및 검증 알고리즘의 순수 Python 3.7 참조 구현]]을 제공합니다. 참조 구현은 데모용으로만 제공되며 실제 운영 환경에서는 사용할 수 없습니다.

== 체인지로그 ==

구현자가 이 BIP의 업데이트를 이해하는 데 도움이 되도록 주요 변경 사항 목록을 제공합니다.

* 2022-08: 참조 코드에서 lift_x의 함수 서명 수정
* 2023-04: 임의 크기의 메시지 허용
* 2024-05: 더 많은 참고 자료와 함께 "애플리케이션" 섹션 업데이트

== 풋노트 ==

<references />

== 감사의 글 ==

이 문서는 수년에 걸쳐 슈노르 기반 서명에 대한 많은 논의의 결과물이며, 존슨 라우, 그렉 맥스웰, 앤드류 포엘스트라, 러스티 러셀, 앤서니 타운스 등의 의견을 받았습니다. 저자들은 [https://github.com/ajtowns/taproot-review 구조화된 검토]에 참여한 분들을 포함하여 귀중한 피드백과 검토를 제공해 주신 모든 분들께 감사의 말씀을 전합니다.
